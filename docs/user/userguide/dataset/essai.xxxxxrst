.. container:: cell markdown

   .. rubric:: The NDDataset object
      :name: the-nddataset-object

.. container:: cell markdown

   The NDDataset is the main object use by **SpectroChemPy**.

   Like numpy ndarrays, NDDataset have the capability to be sliced,
   sorted and subject to matematical operations.

   But, in addition, NDDataset may have units, can be masked and each
   dimensions can have coordinates also with units. This make NDDataset
   aware of unit compatibility, *e.g.*, for binary operation such as
   addtions or subtraction or during the application of mathematical
   operations. In addition or in replacement of numerical data for
   coordinates, NDDatset can also have labeled coordinates where labels
   can be different kind of objects (strings, datetime, numpy nd.ndarray
   or othe NDDatasets, etc...).

   This offers a lot of flexibility in using NDDatasets that, we hope,
   will be useful for applications. See the **Tutorials** for more
   information about such possible applications.

   **SpectroChemPy** provides another kind of data structure,
   aggregating several datasets: **NDPanel**: See

.. container:: cell markdown

   **Below (and in the next sections), we try to give an almost complete
   view of the NDDataset features.**

.. container:: cell code

   .. code:: python

      from spectrochempy import *

.. container:: cell markdown

   Multidimensional array are defined in Spectrochempy using the
   ``NDDataset`` object.

   ``NDDataset`` objects mostly behave as numpy's ``numpy.ndarray``.

   However, unlike raw numpy's ndarray, the presence of optional
   properties make them (hopefully) more appropriate for handling
   spectroscopic information, one of the major objectives of the
   SpectroChemPy package:

   -  **mask**,
   -  **units**,
   -  and **coordset**.

   Additional metadata can also be added to the instances of this class
   through the ``meta`` properties.

.. container:: cell markdown

   .. rubric:: Create a ND-Dataset from scratch
      :name: create-a-nd-dataset-from-scratch

.. container:: cell markdown

   .. rubric:: 1D-Dataset (unidimensional dataset)
      :name: 1d-dataset-unidimensional-dataset

.. container:: cell markdown

   In the following example, a minimal 1D dataset is created from a
   simple list, to which we can add some metadata:

.. container:: cell code

   .. code:: python

      d1D = NDDataset([10., 20., 30.])
      print_(d1D)

.. container:: cell markdown

   .. raw:: html

      <div class='alert-info'>

      **Note**: In the above code, we use of `print_` (with an underscore) not the usual `print` function.
      The `print` output only a short line of information

      </div>

.. container:: cell code

   .. code:: python

      d1D.plot()

.. container:: cell code

   .. code:: python

      print(d1D)

.. container:: cell markdown

   To get a rich display of the dataset, we can simply type on the last
   line of the cell: This output a html version of the information
   string.

.. container:: cell code

   .. code:: python

      d1D

.. container:: cell markdown

   Except few addtional metadata such ``author``, ``created`` ..., there
   is not much differences with respect to a conventional
   ``numpy.ndarray``. For example, one can apply numpy ufunc's directly
   to a NDDataset or make basic arithmetic operation with these objects:

.. container:: cell code

   .. code:: python

      np.sqrt(d1D ** 3)

.. container:: cell code

   .. code:: python

      d1D + d1D / 2.

.. container:: cell markdown

   As seen above, there is some metadata taht are automatically added to
   the dataset:

   -  **``id``** : This is a unique identifier for the object
   -  **``author``** : author determined from the computer name
   -  **``created``**: date/time of creation
   -  **``modified``**: date/time of modification

   additionaly, dataset can have a **``name``** (equal to the ``id`` if
   it is not provided)

   Some other metadata are defined:

   -  **``history``**: history of operation achieved on the object since
      the object creation
   -  **``description``**: A user friendly description of the objects
      purpose or contents.
   -  **``title``**: A title that will be used in plots or in some other
      operation on the objects.

   All this metadata (except, the ``id``, ``created``, ``modified``) can
   be changed by the user.

   For instance:

.. container:: cell code

   .. code:: python

      d1D.title = 'intensity'
      d1D.name = 'mydataset'
      d1D.history = 'created from scratch'
      d1D.description = 'Some experimental measurements'
      d1D

.. container:: cell markdown

   d1D is a 1D (1-dimensional) dataset with only one dimension.

   Some attributes are useful to check this kind of information:

.. container:: cell code

   .. code:: python

      d1D.shape # the shape of 1D contain only one dimension size

.. container:: cell code

   .. code:: python

      d1D.ndim # the number of dimensions

.. container:: cell code

   .. code:: python

      d1D.dims # the name of the dimension (it has been automatically attributed)

.. container:: cell markdown

   **Note**: The names of the dimensions are set automatically. But they
   can be changed, with the limitation that the name must be a single
   letter.

.. container:: cell code

   .. code:: python

      d1D.dims = ['q']  # change the list of dim names.

.. container:: cell code

   .. code:: python

      d1D.dims

.. container:: cell markdown

   .. rubric:: nD-Dataset (multidimensional dataset)
      :name: nd-dataset-multidimensional-dataset

.. container:: cell markdown

   To create a nD NDDataset, we have to provide a nD-array like object
   to the NDDataset instance constructor

.. container:: cell code

   .. code:: python

      a = np.random.rand(2,4,6)   # note here that np (for numpy space has been automatically
                                  # imported with spectrochempy, thus no need to use the
                                  # classical `import numpy as np`)
      a

.. container:: cell code

   .. code:: python

      d2D = NDDataset(a)
      d2D.title = 'Energy'
      d2D.name = '3D dataset creation'
      d2D.history = 'created from scratch'
      d2D.description = 'Some example'
      d2D.dims = ['v','u','t']
      d2D

.. container:: cell markdown

   We can also add all information in a single statement

.. container:: cell code

   .. code:: python

      d2D = NDDataset(a, dims = ['v','u','t'], title = 'Energy', name = '3D_dataset',
                      history = 'created from scratch', description = 'a single line creation example')
      d2D

.. container:: cell markdown

   Three names are attributed at the creation (if they are not provided
   with the ``dims`` attribute, then the name are: 'z','y','x'
   automatically attributed)

.. container:: cell code

   .. code:: python

      d2D.dims

.. container:: cell code

   .. code:: python

      d2D.ndim

.. container:: cell code

   .. code:: python

      d2D.shape

.. container:: cell markdown

   .. rubric:: Units
      :name: units

.. container:: cell markdown

   One interesting possibility for a NDDataset is to have defined units
   for the internal data.

.. container:: cell code

   .. code:: python

      d1D.units = 'eV'

.. container:: cell code

   .. code:: python

      d1D  # note the eV symbol of the units added to the values field below

.. container:: cell markdown

   This allows to make units-aware calculations:

.. container:: cell code

   .. code:: python

      np.sqrt(d1D) # note the results en eV^0.5

.. container:: cell code

   .. code:: python

      time = 5.*ur.second   # ur is a registry containing all available units
      d1D/time              # here we get results in eV/s

.. container:: cell markdown

   Conversion can be done between different units transparently

.. container:: cell code

   .. code:: python

      d1D.to('J')

.. container:: cell code

   .. code:: python

      d1D.to('K')

.. container:: cell markdown

   .. rubric:: Coordinates
      :name: coordinates

.. container:: cell markdown

   The above created ``d2D`` dataset has 3 dimensions, but no coordinate
   for these dimensions. Here arises a big difference with simple
   ``numpy``-arrays:

   -  We can add coordinates to each dimensions of a NDDataset.

.. container:: cell markdown

   To get the list of all defined coordinates, we can use the ``coords``
   attribute:

.. container:: cell code

   .. code:: python

      d2D.coords  # no coordinates, so it returns nothing (None)

.. container:: cell code

   .. code:: python

      d2D.t       # the same for coordinate  u, v, t which are not yet set

.. container:: cell markdown

   To add coordinates, on way is to set them one by one:

.. container:: cell code

   .. code:: python

      d2D.t = np.arange(6)*.1 # we need a sequence of 6 values for `t` dimension (see shape above)
      d2D.t.title = 'time'
      d2D.t.units = 'seconds'
      d2D.coords # now return a list of coordinates

.. container:: cell code

   .. code:: python

      d2D.t

.. container:: cell code

   .. code:: python

      d2D.coords('t')  # Alternative way to get a given coordinates

.. container:: cell code

   .. code:: python

      d2D['t'] # another alternative way to get a given coordinates

.. container:: cell markdown

   The two other coordinates u and v are still undefined

.. container:: cell code

   .. code:: python

      d2D.u

.. container:: cell code

   .. code:: python

      d2D.v

.. container:: cell markdown

   When the dataset is printed, only the information for the existing
   coordinates is given.

.. container:: cell code

   .. code:: python

      d2D

.. container:: cell markdown

   Programatically, we can use the attribute ``is_empty`` or
   ``has_data`` to check this

.. container:: cell code

   .. code:: python

      d2D.v.has_data, d2D.v.is_empty

.. container:: cell markdown

   An error is raised when a coordinate doesn't exist

.. container:: cell code

   .. code:: python

      try:
          d2D.x
      except KeyError:
          error_('not found')

.. container:: cell markdown

   In some case it can also be usefull to get a coordinate from its
   title instead of its name (the limitation is that if several
   coordinates have the same title, then only the first ones that is
   found in the coordinate list, will be returned - this can be
   ambiguous)

.. container:: cell code

   .. code:: python

      d2D['time']

.. container:: cell code

   .. code:: python

      d2D.time

.. container:: cell markdown

   It is possible to use labels instead of numerical coordinates. They
   are sequence of objects .The length of the sequence must be equal to
   the size of a dimension

.. container:: cell code

   .. code:: python

      from datetime import datetime, timedelta, time
      timedelta()

.. container:: cell code

   .. code:: python

      start = timedelta(0)
      times = [start + timedelta(seconds=x*60) for x in range(6)]
      d2D.t = None
      d2D.t.labels = times
      d2D.t.title = 'time'
      d2D

.. container:: cell code

   .. code:: python

      tags = list('abcdef')
      d2D.t.labels = tags
      d2D

.. container:: cell markdown

   In this case, getting a coordinate that doesn't possess numerical
   data but labels, will return the labels

.. container:: cell code

   .. code:: python

      d2D.time

.. container:: cell markdown

   Sometimes it is not necessary to have different coordinates for the
   various axes.

   For example, if we have a square matrix with the same coordinate in
   the two dimensions, the second dimension can refer to the first.

.. container:: cell code

   .. code:: python

      a = np.diag((3,3,2.5))
      nd = NDDataset(a, coords=CoordSet(x=np.arange(3), y='x'))
      nd

.. container:: cell markdown

   .. rubric:: Create a NDDataset: full example
      :name: create-a-nddataset-full-example

   There are many ways to create ``NDDataset`` objects.

   Above we have created a ``NDDataset`` from a simple list, but also
   from a ``numpy.ndarray``).

   Below is an example of a 3D-Dataset created from a ``numpy.ndarray``
   to which axes for each dimension can be added at creation.

   Let's first create the 3 one-dimensional coordinates, for which we
   can define ``labels``, ``units``, and ``masks``!

.. container:: cell code

   .. code:: python

      coord0 = Coord(data=np.linspace(4000., 1000., 100),
                     labels=None,
                     mask=None,
                     units="cm^-1",
                     title='wavenumber')

      coord1 = Coord(data=np.linspace(0., 60., 60),
                     labels=None,
                     mask=None,
                     units="minutes",
                     title='time-on-stream')

      coord2 = Coord(data=np.linspace(200., 300., 3),
                     labels=['cold', 'normal', 'hot'],
                     mask=None,
                     units="K",
                     title='temperature')

.. container:: cell markdown

   Here is the displayed info for coord1 for instance:

.. container:: cell code

   .. code:: python

      coord1

.. container:: cell markdown

   Now we create some 3D data (a ``numpy.ndarray``):

.. container:: cell code

   .. code:: python

      nd_data = np.array(
          [np.array([np.sin(coord2.data * 2. * np.pi / 4000.) * np.exp(-y / 60.) for y in coord1.data]) * float(t)
           for t in coord0.data]) ** 2

.. container:: cell markdown

   The dataset is now created with these data and axis. All needed
   information are passed as parameter of the NDDataset instance
   constructor.

.. container:: cell code

   .. code:: python

      d3D = NDDataset(nd_data,
                            name = 'mydataset',
                            coords=[coord0, coord1, coord2],
                            title='Absorbance',
                            units='absorbance'
                            )

      d3D.description = """Dataset example created for this tutorial.
      It's a 3-D dataset (with dimensionless intensity)"""

      d3D.author = 'Blake & Mortimer'

.. container:: cell markdown

   We can get some information about this object:

.. container:: cell code

   .. code:: python

      d3D

.. container:: cell markdown

   One can set all the coordinates independantly

.. container:: cell code

   .. code:: python

      d3D = NDDataset(nd_data,
                            name = 'mydataset',
                            title='Absorbance',
                            units='absorbance'
                            )
      d3D.description = """Dataset example created for this tutorial.
      It's a 3-D dataset (with dimensionless intensity)"""

      d3D.author = 'Blake & Mortimer'
      d3D

.. container:: cell code

   .. code:: python

      d3D.set_coords(x=coord2, y=coord1, z=coord0)          # syntax 1
      d3D.set_coords({'x':coord2, 'y':coord1, 'z':coord0})  # syntax 2
      d3D

.. container:: cell markdown

   One can add several coordinates to the same dimension

.. container:: cell code

   .. code:: python

      coord2b = Coord([1,2,3], units='millitesla', title='magnetic field')

.. container:: cell code

   .. code:: python

      d3D.set_coords(x=CoordSet(coord2,coord2b), y=coord1, z=coord0)
      d3D

.. container:: cell markdown

   Some additional information about coordinate setting syntax

.. container:: cell code

   .. code:: python

      # A. fist syntax (probably the safer because the name of the dimension is specified, so this is less prone to errors!)
      d3D.set_coords(x=CoordSet(coord2,coord2b), y=coord1, z=coord0)
      d3D.set_coords(x=[coord2,coord2b], y=coord1, z=coord0) # equivalent

      # B. second syntax in the order of the dimensions: z,y,x (if no swap or transpopse has been performed)
      d3D.set_coords(coord0, coord1, [coord2,coord2b])
      d3D.set_coords((coord0, coord1, [coord2,coord2b]))  # equivalent

      # C. third syntax (from a dictionary)
      d3D.set_coords({'z':coord0, 'y':coord1, 'x':[coord2,coord2b]})

      # D. Fourth syntax (from another coordset)
      d3D.set_coords(**CoordSet(z=coord0, y=coord1, x=[coord2,coord2b]))   # note the **

      # It is also possible to use the coords property (with slightly less possibility)
      d3D.coords = coord0, coord1,[coord2,coord2b]
      d3D.coords = {'z':coord0, 'y':coord1, 'x':[coord2,coord2b]}
      d3D.coords = CoordSet(z=coord0, y=coord1, x=[coord2,coord2b])

.. container:: cell markdown

   WARNING: do not use list for setting multiples coordinates! use
   tuples

.. container:: cell code

   .. code:: python

      # This raise an error (list have another signification: it's used to set a "same dim" CoordSet see example A or B)
      try:
          d3D.coords = [coord0, coord1, coord2]
      except ValueError:
          error_('Coordinates must be of the same size for a dimension with multiple coordinates')

      # This works (not a tuple `()`, not a list `[]`)
      d3D.coords = (coord0, coord1, coord2)

.. container:: cell markdown

   .. rubric:: Copying existing NDDataset
      :name: copying-existing-nddataset

   To copy an existing dataset, this is as simple as:

.. container:: cell code

   .. code:: python

      d3D_copy = d3D.copy()

.. container:: cell markdown

   or alternatively:

.. container:: cell code

   .. code:: python

      d3D_copy = d3D[:]

.. container:: cell markdown

   Finally, it is also possible to initialize a dataset using an
   existing one:

.. container:: cell code

   .. code:: python

      d3Dduplicate = NDDataset(d3D, name='duplicate of %s'%d3D.name , units='absorbance')
      d3Dduplicate

.. container:: cell markdown

   .. rubric:: Other ways to create NDDatasets
      :name: other-ways-to-create-nddatasets

   Some numpy creation function can be used to set up the initial
   dataset array: `numpy array creation
   routines <https://docs.scipy.org/doc/numpy/reference/routines.array-creation.html#routines-array-creation>`__

.. container:: cell code

   .. code:: python

      dz = zeros((2, 2), units='meters', title='Datasets with only zeros')
      dz

.. container:: cell code

   .. code:: python

      do = ones((2, 2), units='kilograms', title='Datasets with only ones')
      do

.. container:: cell code

   .. code:: python

      df = full((2, 2), fill_value=1.25, units='radians',
           title='with only float=1.25')
      df

.. container:: cell markdown

   As with numpy, it is also possible to take another dataset as a
   template:

.. container:: cell code

   .. code:: python

      do = ones((2, 3), dtype=bool)
      do[1,1]=0
      do

.. container:: cell markdown

   Now we use the previous dataset ``do`` as a template, for the shape,
   but we can change the ``dtype``.

.. container:: cell code

   .. code:: python

      df = full_like(d3D, dtype=np.float64, fill_value=2.5)
      df

.. container:: cell markdown

   .. rubric:: Importing from external dataset
      :name: importing-from-external-dataset

   NDDataset can be created from the importation of external data

   A **test**'s data folder contains some data for experimenting some
   features of datasets.

.. container:: cell code

   .. code:: python

      # let check if this directory exists and display its actual content:
      import os

      datadir = preferences.datadir
      if os.path.exists(datadir):
          # let's display only the last part of the path
          print(os.path.basename(datadir))

.. container:: cell markdown

   .. rubric:: Reading a IR dataset saved by OMNIC (.spg extension)
      :name: reading-a-ir-dataset-saved-by-omnic-spg-extension

   Even if we do not specify the **datadir**, the application first look
   in tht directory by default.

.. container:: cell code

   .. code:: python

      dataset = NDDataset.read_omnic(os.path.join('irdata', 'nh4y-activation.spg'))
      dataset

.. container:: cell markdown

   .. rubric:: Slicing a NDDataset
      :name: slicing-a-nddataset

.. container:: cell markdown

   NDDataset can be sliced like conventional numpy-array...

   *e.g.,*:

   #. by index, using a slice such as [3], [0:10], [:, 3:4], [...,
      5:10], ...

   #. by values, using a slice such as [3000.0:3500.0], [..., 300.0],
      ...

   #. by labels, using a slice such as ['monday':'friday'], ...

.. container:: cell code

   .. code:: python

      new = d3D[..., 0]
      new

.. container:: cell markdown

   or using the axes labels:

.. container:: cell code

   .. code:: python

      new = d3D[..., 'hot']
      new

.. container:: cell markdown

   Be sure to use the correct type for slicing.

   Floats are used for slicing by values

.. container:: cell code

   .. code:: python

      correct = d3D[2000.]
      correct

.. container:: cell code

   .. code:: python

      outside_limits = d3D[2000]

.. container:: cell markdown

   .. raw:: html

      <div class='alert alert-info'>

      **NOTE:**
      If one use an integer value (2000), then the slicing is made **by index not by value**, and in the following
      particular case, an `Error` is issued as index 2000 does not exists (size along axis `x` (axis:0) is only 100, so
      that index vary between 0 and 99!).

      </div>

.. container:: cell markdown

   One can mixed slicing methods for different dimension:

.. container:: cell code

   .. code:: python

      new = d3D[4000.0:2000., 0, 'normal':'hot']
      new

.. container:: cell markdown

   .. rubric:: Loading of experimental data
      :name: loading-of-experimental-data

.. container:: cell markdown

   .. rubric:: NMR Data
      :name: nmr-data

.. container:: cell markdown

   Now, lets load a NMR dataset (in the Bruker format).

.. container:: cell code

   .. code:: python

      path = os.path.join(datadir, 'nmrdata', 'bruker', 'tests', 'nmr', 'topspin_1d')

      # load the data in a new dataset
      ndd = NDDataset()
      ndd.read_bruker_nmr(path, expno=1, remove_digital_filter=True)
      ndd

.. container:: cell code

   .. code:: python

      # view it...
      _ = ndd.plot(color='blue')

.. container:: cell code

   .. code:: python

      path = os.path.join(datadir, 'nmrdata', 'bruker', 'tests', 'nmr', 'topspin_2d')

      # load the data directly (no need to create the dataset first)
      ndd2 = NDDataset.read_bruker_nmr(path, expno=1, remove_digital_filter=True)

      # view it...
      ndd2.x.to('s')
      ndd2.y.to('ms')

      ax = ndd2.plot(method='map')
      ndd2

.. container:: cell markdown

   .. rubric:: IR data
      :name: ir-data

.. container:: cell code

   .. code:: python

      dataset = NDDataset.read_omnic(os.path.join(datadir, 'irdata', 'nh4y-activation.spg'))
      dataset

.. container:: cell code

   .. code:: python

      ax = dataset.plot(method='stack')

.. container:: cell markdown

   .. rubric:: Masks
      :name: masks

.. container:: cell markdown

   if we try to get for example the maximum of the previous dataset, we
   face a problem due to the saturation around 1100 cm\ :math:`^{-1}`.

.. container:: cell code

   .. code:: python

      dataset.max()

.. container:: cell markdown

   One way is to apply the max function to only a part of the spectrum.
   Another way is to mask the undesired data.

   Masking values in a dataset is straigthforward. Just set a value
   ``masked`` or True for those data you want to mask.

.. container:: cell code

   .. code:: python

      dataset[1290.:890.] = MASKED

.. container:: cell markdown

   Now the max function return the correct position

.. container:: cell code

   .. code:: python

      dataset.max()

.. container:: cell markdown

   Here is a display the figure with the new mask

.. container:: cell code

   .. code:: python

      _ = dataset.plot_stack()

.. container:: cell markdown

   .. rubric:: Transposition
      :name: transposition

.. container:: cell markdown

   Dataset can be transposed

.. container:: cell code

   .. code:: python

      datasetT = dataset.T
      datasetT

.. container:: cell markdown

   As it can be observed the dimension ``x``\ and ``y``\ have been
   exchanged, *e.g.* the originalshape was **(x:5549, y:55)**, and after
   transposition it is **(y:55, x:5549)**. (the dimension names stay the
   same, but the index of the corresponding axis are exchanged).

.. container:: cell markdown

   Let's vizualize the result:

.. container:: cell code

   .. code:: python

      _ = datasetT.plot()

.. container:: cell code

   .. code:: python

      dataset[:, 4000.:3000.], datasetT[4000.:3000.]

.. container:: cell markdown

   .. rubric:: Numpy universal functions (ufunc's)
      :name: numpy-universal-functions-ufuncs

   A numpy universal function (or ``numpy.ufunc`` for short) is a
   function that operates on ``numpy.ndarray`` in an element-by-element
   fashion. It's vectorized and so rather fast.

   As SpectroChemPy NDDataset imitate the behaviour of numpy objects,
   many numpy ufuncs can be applied directly.

   For example, if you need all the elements of a NDDataset to be
   changed to the squared rooted values, you can use the ``numpy.sqrt``
   function:

.. container:: cell code

   .. code:: python

      da = NDDataset([1., 2., 3.])
      da_sqrt = np.sqrt(da)
      da_sqrt

.. container:: cell markdown

   .. rubric:: Ufuncs with NDDataset with units
      :name: ufuncs-with-nddataset-with-units

   When NDDataset have units, some restrictions apply on the use of
   ufuncs:

   Some function functions accept only dimensionless quantities. This is
   the case for example of logarithmic functions: :``exp`` and ``log``.

.. container:: cell code

   .. code:: python

      np.log10(da)

.. container:: cell code

   .. code:: python

      da.units = ur.cm

      try:
          np.log10(da)
      except DimensionalityError as e:
          error_(e)

.. container:: cell markdown

   .. rubric:: Complex or hypercomplex NDDatasets
      :name: complex-or-hypercomplex-nddatasets

   NDDataset objects with complex data are handled differently than in
   ``numpy.ndarray``.

   Instead, complex data are stored by interlacing the real and
   imaginary part. This allows the definition of data that can be
   complex in several axis, and *e .g.,* allows 2D-hypercomplex array
   that can be transposed (useful for NMR data).

.. container:: cell code

   .. code:: python

      da = NDDataset([[1. + 2.j, 2. + 0j], [1.3 + 2.j, 2. + 0.5j], [1. + 4.2j, 2. + 3j], [5. + 4.2j, 2. + 3j]])
      da

.. container:: cell markdown

   A dataset of type float can be transformed into a complex dataset
   (using two cionsecutive rows to create a complex row)

.. container:: cell code

   .. code:: python

      da = NDDataset(np.arange(40).reshape(10,4))
      da

.. container:: cell code

   .. code:: python

      dac = da.set_complex()
      dac

.. container:: cell markdown

   Note the ``x``\ dimension size is divided by a factor of two

.. container:: cell markdown

   A dataset which is complex in two dimensions is called hypercomplex
   (it's datatype in SpectroChemPy is set to quaternion).

.. container:: cell code

   .. code:: python

      daq = da.set_quaternion()   # equivalently one can use the set_hypercomplex method
      daq

.. container:: cell code

   .. code:: python

      daq.dtype
